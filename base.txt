一、基本概念
1、编译预处理、编译、连接。
2、内存映像：代码段、静态数据段、堆栈段。代码段包含源程序中的可执行语句序列；静态数据段存放全局变量、静态变量、符号表等；堆栈段留给函数和线程使用；
3、堆和自由存储空间不属于程序，属于操作系统，可以通过动态内存分配指令获取使用权。

二、程序入门
1、内部名称
1）C语言中，所有函数不是局部于编译单元的static函数，就是具有extern和global作用域的全局函数。不同编译单元中的static函数可以同名，全局函数不能同名。C语言转换时只说在函数名前面添加前缀'_'。
2）C++重命名在前面添加所属各级作用域及重载函数的经过编码的参数信息。
2、全局变量extern或者static存放在程序的静态数据区，在程序进入main()之前创建，在main()结束后销毁，编译器用0初始化。函数内的static局部变量和类中的static数据成员都具有static存储类型，会被移到程序的静态数据区，默认初始化为0。
3、区分初始化和赋值：前者发生在对象或变量创建的时候，后者在创建后进行。
4、字节是内存编址的最小单位，最小的对象(包括空对象)也至少占据1个字节的内存空间。
5、void类型指针和NULL指针区别：NULL是可以赋值给任何类型指针的值0，void*是合法指针，通常在函数参数中传递一个函数与期调用者之间约定好类型的对象地址；NULL是合法指针，但不是一个有效指针。
6、由于派生类和基类之间是is-a关系，可以直接将派生类对象转化为基类对象，虽然会发生内存截断，确是安全的。因为派生类对象必须保证其基类子对象完整性，基类子对象内存映像和真正的基类对象完全一样。
7、不可以把基类对象直接转换为派生类对象；对应基本类型的强制换行一定要区分值的截断和内存截断的不同。
8、两个同符号浮点数之差的绝对值小于或等于某个可接受的误差，就认为他们是相等的。
9、先列后行遍历发生的页面交换次数比先行后列多，且cache命中率相对也低。

三、常量
1、字面常量只能引用，不能修改。一般保存在程序的符号表里而不是一般的数据区。符号表是只读的。
2、#define定义的宏常量，在编译阶段前已经被替换为所代表的字面常量了，因此宏常量本质上是字面常量。
3、C++const定义的常量需根据具体情况定：对应基本数据类型，编译器会放到符号表中不分配存储空间。大对象需要分配存储空间。
4、对于基础数据类型的const常量，编译器会重新在内存创建一个拷贝；构造类型的const常量不会。
5、const和#define比较：
1）const常量有数据类型，宏常量没有数据类型。编译器可以对前者进行静态类型安全监测，后者只是字符替换，没有安全检查。
2）可以对const常量进行调试。
6、const可以用于：数据成员、成员函数、返回类型、const参数、符号常量。
7、类中的常量，非静态的const数据成员是属于每一个对象成员的，在某个对象生存期限内是常量，对整个类是可变的，除非是static const。非静态const数据成员只能在类构造函数的初始化列表中进行初始化。
8、C语言中const符号常量定义的默认连接类型是extern外连接，同全局变量。如果在头文件中定义必须使用static关键字，这样每一个包含该头文件的编译单元都会分别拥有该常量的独立定义实体。
9、C++中const默认连接类型是static，在头文件定义不需要static关键字。
10、const对指针的影响。const位于*左侧，用来修饰指针所指向的为常量。const位于*右侧，修饰指针本身，指针本身是常量。
1）const int *a; int const *a表示指针所指向的内容是常量，不能对内容进行更改操作；
2）int * const a表示指针本身是常量，不能对指针本身进行操作。

四、函数设计基础
1、函数堆栈作用：在进入函数前保持环境变量和返回地址；进入函数时保存实参的拷贝；在函数体内保存局部变量。
2、变量、常量和函数定义了4种存储类型：extern和static为永久的(在整个程序执行期间都存着)，auto和register为临时的(保存在堆栈和寄存器中)。
1）默认情况下，全局变量和全局函数的存储类型是extern。
2）变量和函数显式的加上extern声明，其他编译单元中的函数也能调用。为外连接。
3）变量和函数显式的加上static声明，只能被同一个编译单元的函数调用。为内连接。
4）全局常量默认存储类型是static。
3、使用const提高函数健壮性。
1）如果输入参数采用指针传递，加const修饰可以防止意外的改动该指针指向的内存单元，起到保护的作用；
2）如果给指针传递的函数返回值加上const，那么函数返回值是一种契约性常量，不能被直接修改，而且只能复制给加const修饰的同类型指针。eg：const char* GetString(void);const char *str = GetString()。

五、指针、数组
1、指针的值就是内存单元的地址。
2、函数指针传递其实是在传递一个地址二不是该地址指向的对象。双指针的传递(char **p)建议使用指针的引用(char* &p)。
3、数组名字本身就是一个指针，是一个指针常量，等价于int * const a; 数组名的值就是数组第一个元素的内存单元首地址，a = &a[0]。
4、二维数组等价于指向一维数组的指针，int b[3][4]等价于 int (* const b)[4]。三维数组等价于指向二维数组的指针，int (* const c)[4][5]。
5、把数组作为参数传递给函数时，并非把整个数组的内容传递进去，此时数组退化为一个同类型的指针。
6、对于多维数组传递，必须指出除第一维之外的所有维度的长度。void output(const int a[][20], int nums);
7、多维数组应转换为其等价的指向一维数组的指针。int a[m][n]等价int (*a)[n]。a是指向第一行的指针，a+1为指向第二行的指针。可转换为void output(const int (*a)[20],  int nums);
8、a[i][j]、(*(a+i))[j]、*(a[i]+j)、*(*(a+i)+j)四种表达等价。
9、删除数组空间时使用delete []p。
10、多维数组动态申请：char (*p)[4] = new char[3][4]; char (*q)[4][5] = new char[3][4][5]。
11、函数指针：int (*fun)(const char *);
1）函数指针是指向函数体的指针，其值是函数体的首地址。函数名就代表函数的首地址。
2）通过函数指针数组实现同类型函数的批量调用，在C++动态决议的虚拟机制中使用的vtable就是一个用来保存虚成员函数地址的函数指针数组。double (*fp[5])(double) = {sqrt, fabs, cos, sin, exp};
12、引用和指针的比较：
1）引用在创建的同时必须初始化，即引用一个有效的对象；指针不必初始化，可以在定义后任何地方赋值。
2）不存在NULL的引用，引用必须和合法的存储单元关联；指针可以是NULL。
3）引用一旦被初始化就不能被改变，指针可以改变为指向另一个对象。
4）引用的创建和销毁并不会调用类的拷贝构造函数和析构函数。
5）语言层面上，引用的用法和对象一样；二进制层面，引用一杯通过指针来实现的，不过编译器帮我们完成转换。

六、高级数据类型
1、struct和class除了"默认的成员访问权限"不用外，其他没有区别。struct默认访问限定符为public，class默认是private。
2、成员对齐：
1）对应复合类型(结构或类)的对象，如果他的起始地址能够满足其中要求最严格的那个数据成员的自然对齐要求，那么他就是自然对齐的。
2）如果那个数据成员又是一个复合类型的对象，则依次类推，知道最后都是基本类型的数据成员。
3）一般都采用按照声明的先后顺序从低地址到高地址依次布放。
4）编译器在考虑一个类型的大小时，不仅要考虑一个对象的对齐要求，还要考虑该类型对象数组的对齐要求，保证使用对象数组和单个对象访问效率一样。
struct R{
char m_ch;
double m_width;
char m_name[6];
}; //24字节
struct T{
int m_no;
R m_r;
}; //32字节
struct U{
bool m_ok;
T m_t;
}; //40字节
5）为节省内存可以按照从大到小的顺序从前到后依次声明数据成员。
3、枚举enum允许我们定义特定用途的一组符号常量，表明这种类型的变量可以取值的范围。使用匿名枚举来定义程序相关常量集合，可以取代宏常量和const常量。
enum{
    AAA = 1;
    BBB = 2;
};
4、头文件的所有内容最终都会被合并到一个或几个源文件中，每一个包含的头文件递归的展开后形成的源文件叫编译单元。

七、面向对象程序设计
1、C++对象模型：
1）非静态数据成员放在每一个对象体内作为对象专有的数据成员。
2）静态数据成员被提取出来放在程序的静态数据区内，该类所有对象共享，仅存在一份。
3）静态和非静态成员函数都被提取放在程序的代码段中并为该类的所有对象共享，每个成员函数只有一份代码实体。
4）类内嵌套定义的各种类型与放在类外面除了作用域不同外没有本质区别。
5）构成对象本身的只有数据，任何成员函数都不隶属于任何一个对象，非静态成员函数与对象的关系就是绑定，绑定的中介就是this指针。
2、增加了继承和虚函数的类
1）派生类继承基类的非静态数据成员，并作为自己对象的专用数据成员。
2）派生类继承基类的非静态成员函数，并作为自己的成员函数一样访问。
3）为每一个多态类创建一个虚函数指针数组vtable(在静态数据区)，该类的所有虚函数(继承自基类或者新增的)的地址都保存在这张表。
4）如果基类已经插入了vptr，派生类将继承和重用改vptr。
5）若果派生类是从多个基类继承或者多个继承分支，则派生类将从这些分支的每个分支上继承一个vptr，编译器也会生成多个vtable。分别与它的多态基类对应。
6）vptr在派生类对象的相对位置不变，一般都放在所有数据成员的最前面。
7）为支持RTTI，为每个多态类创建一个type_info对象，并把其地址保存在vtable中的固定位置，一般为第一个。
3、虚函数指针的排序规律：
1）一个虚函数在当前class中第一次出现，则将其地址插入到该class的每一个vtable的尾部。
2）如果派生类改写了基类的虚函数，则函数的地址在派生类vtable的位置与在基类vtable中位置一致。
4、vptr处理过程：
1）vptr在根类的构造函数中被初始化，在后来的基类构造函数中，实际上都是在不断地被改写以指向当期构造函数对应的基类的vtable。
2）vptr必须随着对象类型的变化而不断地改变它的指向，以保证其值和当前对象的实际类型一致。
3）vptr肯定是第一个被初始化和改写的成员，在所有代码执行之前进行。
4）析构函数中，vptr则应该在所有用户代码指向完之后被改写为指向其直接基类的vtable。 因为在一个对象的析构过程中，是沿着继承分支向上依次退化为各个基类对象的。
5、虚函数
1）纯虚函数声明如下：virtual void funtion1()=0; 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。
2）虚函数声明如下：virtual ReturnType FunctionName(Parameter)；虚函数必须实现，如果不实现，编译器将报错。
3）对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。
4）实现了纯虚函数的子类，该纯虚函数在子类中就变成了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。
5）虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。
6）在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。
7）友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。
8）析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。
9）构造函数不能是虚函数。
6、多态性：
1）系统能够在运行时，能够根据其类型确定调用哪个重载的成员函数的能力，称为多态性，或叫滞后联编(late binding)。
2）多态特性的工作依赖虚函数的定义，在需要解决多态问题的重载成员函数前，加上virtual关键字，那么该成员函数就变成了虚函数。
7、隐含成员：有可能的隐含成员包括，若干vptr、默认构造函数、默认拷贝构造函数、析构函数和默认拷贝赋值函数。
8、static声明和定义的程序元素，无论作用域都是static存储类型，并且生存期限为永久，在程序开始时创建在结束时销毁。静态成员函数不需要this指针参数，通过作用域解析运算符(::)直接引用。
9、虚函数：一旦类的函数被声明为虚函数，其派生类的对应函数也自动成为虚函数。建议每一个派生层次显示的声明虚函数。
10、抽象基类：
1）不能被实例化的类，目的就是让其派生类继承并实现它的接口方法，通常也称为抽象基类。
2）函数初始化为0意味着函数的地址为0，编译器不会为该函数编址，从而阻止该类的实例化行为。
3）只有虚函数才能被初始化为0.











