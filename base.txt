一、基本概念
1、编译预处理、编译、连接。
2、内存映像：代码段、静态数据段、堆栈段。代码段包含源程序中的可执行语句序列；静态数据段存放全局变量、静态变量、符号表等；堆栈段留给函数和线程使用；
3、堆和自由存储空间不属于程序，属于操作系统，可以通过动态内存分配指令获取使用权。

二、程序入门
1、内部名称
1）C语言中，所有函数不是局部于编译单元的static函数，就是具有extern和global作用域的全局函数。不同编译单元中的static函数可以同名，全局函数不能同名。C语言转换时只说在函数名前面添加前缀'_'。
2）C++重命名在前面添加所属各级作用域及重载函数的经过编码的参数信息。
2、全局变量extern或者static存放在程序的静态数据区，在程序进入main()之前创建，在main()结束后销毁，编译器用0初始化。函数内的static局部变量和类中的static数据成员都具有static存储类型，会被移到程序的静态数据区，默认初始化为0。
3、区分初始化和赋值：前者发生在对象或变量创建的时候，后者在创建后进行。
4、字节是内存编址的最小单位，最小的对象(包括空对象)也至少占据1个字节的内存空间。
5、void类型指针和NULL指针区别：NULL是可以赋值给任何类型指针的值0，void*是合法指针，通常在函数参数中传递一个函数与期调用者之间约定好类型的对象地址；NULL是合法指针，但不是一个有效指针。
6、由于派生类和基类之间是is-a关系，可以直接将派生类对象转化为基类对象，虽然会发生内存截断，确是安全的。因为派生类对象必须保证其基类子对象完整性，基类子对象内存映像和真正的基类对象完全一样。
7、不可以把基类对象直接转换为派生类对象；对应基本类型的强制换行一定要区分值的截断和内存截断的不同。
8、两个同符号浮点数之差的绝对值小于或等于某个可接受的误差，就认为他们是相等的。
9、先列后行遍历发生的页面交换次数比先行后列多，且cache命中率相对也低。

三、常量
1、字面常量只能引用，不能修改。一般保存在程序的符号表里而不是一般的数据区。符号表是只读的。
2、#define定义的宏常量，在编译阶段前已经被替换为所代表的字面常量了，因此宏常量本质上是字面常量。
3、C++const定义的常量需根据具体情况定：对应基本数据类型，编译器会放到符号表中不分配存储空间。大对象需要分配存储空间。
4、对于基础数据类型的const常量，编译器会重新在内存创建一个拷贝；构造类型的const常量不会。
5、const和#define比较：
1）const常量有数据类型，宏常量没有数据类型。编译器可以对前者进行静态类型安全监测，后者只是字符替换，没有安全检查。
2）可以对const常量进行调试。
6、const可以用于：数据成员、成员函数、返回类型、const参数、符号常量。
7、类中的常量，非静态的const数据成员是属于每一个对象成员的，在某个对象生存期限内是常量，对整个类是可变的，除非是static const。非静态const数据成员只能在类构造函数的初始化列表中进行初始化。
8、C语言中const符号常量定义的默认连接类型是extern外连接，同全局变量。如果在头文件中定义必须使用static关键字，这样每一个包含该头文件的编译单元都会分别拥有该常量的独立定义实体。
9、C++中const默认连接类型是static，在头文件定义不需要static关键字。
10、const对指针的影响。const位于*左侧，用来修饰指针所指向的为常量。const位于*右侧，修饰指针本身，指针本身是常量。
1）const int *a; int const *a表示指针所指向的内容是常量，不能对内容进行更改操作；
2）int * const a表示指针本身是常量，不能对指针本身进行操作。

四、函数设计基础
1、函数堆栈作用：在进入函数前保持环境变量和返回地址；进入函数时保存实参的拷贝；在函数体内保存局部变量。
2、变量、常量和函数定义了4种存储类型：extern和static为永久的(在整个程序执行期间都存着)，auto和register为临时的(保存在堆栈和寄存器中)。
1）默认情况下，全局变量和全局函数的存储类型是extern。
2）变量和函数显式的加上extern声明，其他编译单元中的函数也能调用。为外连接。
3）变量和函数显式的加上static声明，只能被同一个编译单元的函数调用。为内连接。
4）全局常量默认存储类型是static。
3、使用const提高函数健壮性。
1）如果输入参数采用指针传递，加const修饰可以防止意外的改动该指针指向的内存单元，起到保护的作用；
2）如果给指针传递的函数返回值加上const，那么函数返回值是一种契约性常量，不能被直接修改，而且只能复制给加const修饰的同类型指针。eg：const char* GetString(void);const char *str = GetString()。

五、指针、数组
1、指针的值就是内存单元的地址。
2、函数指针传递其实是在传递一个地址二不是该地址指向的对象。双指针的传递(char **p)建议使用指针的引用(char* &p)。
3、数组名字本身就是一个指针，是一个指针常量，等价于int * const a; 数组名的值就是数组第一个元素的内存单元首地址，a = &a[0]。
4、二维数组等价于指向一维数组的指针，int b[3][4]等价于 int (* const b)[4]。三维数组等价于指向二维数组的指针，int (* const c)[4][5]。
5、把数组作为参数传递给函数时，并非把整个数组的内容传递进去，此时数组退化为一个同类型的指针。
6、对于多维数组传递，必须指出除第一维之外的所有维度的长度。void output(const int a[][20], int nums);
7、多维数组应转换为其等价的指向一维数组的指针。int a[m][n]等价int (*a)[n]。a是指向第一行的指针，a+1为指向第二行的指针。可转换为void output(const int (*a)[20],  int nums);
8、a[i][j]、(*(a+i))[j]、*(a[i]+j)、*(*(a+i)+j)四种表达等价。
9、删除数组空间时使用delete []p。
10、多维数组动态申请：char (*p)[4] = new char[3][4]; char (*q)[4][5] = new char[3][4][5]。
11、函数指针：int (*fun)(const char *);
1）函数指针是指向函数体的指针，其值是函数体的首地址。函数名就代表函数的首地址。
2）通过函数指针数组实现同类型函数的批量调用，在C++动态决议的虚拟机制中使用的vtable就是一个用来保存虚成员函数地址的函数指针数组。double (*fp[5])(double) = {sqrt, fabs, cos, sin, exp};
12、引用和指针的比较：
1）引用在创建的同时必须初始化，即引用一个有效的对象；指针不必初始化，可以在定义后任何地方赋值。
2）不存在NULL的引用，引用必须和合法的存储单元关联；指针可以是NULL。
3）引用一旦被初始化就不能被改变，指针可以改变为指向另一个对象。
4）引用的创建和销毁并不会调用类的拷贝构造函数和析构函数。
5）语言层面上，引用的用法和对象一样；二进制层面，引用一杯通过指针来实现的，不过编译器帮我们完成转换。

六、高级数据类型
1、struct和class除了"默认的成员访问权限"不用外，其他没有区别。struct默认访问限定符为public，class默认是private。
2、成员对齐：
1）对应复合类型(结构或类)的对象，如果他的起始地址能够满足其中要求最严格的那个数据成员的自然对齐要求，那么他就是自然对齐的。
2）如果那个数据成员又是一个复合类型的对象，则依次类推，知道最后都是基本类型的数据成员。
3）一般都采用按照声明的先后顺序从低地址到高地址依次布放。
4）编译器在考虑一个类型的大小时，不仅要考虑一个对象的对齐要求，还要考虑该类型对象数组的对齐要求，保证使用对象数组和单个对象访问效率一样。
struct R{
char m_ch;
double m_width;
char m_name[6];
}; //24字节
struct T{
int m_no;
R m_r;
}; //32字节
struct U{
bool m_ok;
T m_t;
}; //40字节
5）为节省内存可以按照从大到小的顺序从前到后依次声明数据成员。
3、枚举enum允许我们定义特定用途的一组符号常量，表明这种类型的变量可以取值的范围。使用匿名枚举来定义程序相关常量集合，可以取代宏常量和const常量。
enum{
    AAA = 1;
    BBB = 2;
};
4、头文件的所有内容最终都会被合并到一个或几个源文件中，每一个包含的头文件递归的展开后形成的源文件叫编译单元。

七、面向对象程序设计
1、C++对象模型：
1）非静态数据成员放在每一个对象体内作为对象专有的数据成员。
2）静态数据成员被提取出来放在程序的静态数据区内，该类所有对象共享，仅存在一份。
3）静态和非静态成员函数都被提取放在程序的代码段中并为该类的所有对象共享，每个成员函数只有一份代码实体。
4）类内嵌套定义的各种类型与放在类外面除了作用域不同外没有本质区别。
5）构成对象本身的只有数据，任何成员函数都不隶属于任何一个对象，非静态成员函数与对象的关系就是绑定，绑定的中介就是this指针。
2、增加了继承和虚函数的类
1）派生类继承基类的非静态数据成员，并作为自己对象的专用数据成员。
2）派生类继承基类的非静态成员函数，并作为自己的成员函数一样访问。
3）为每一个多态类创建一个虚函数指针数组vtable(在静态数据区)，该类的所有虚函数(继承自基类或者新增的)的地址都保存在这张表。
4）如果基类已经插入了vptr，派生类将继承和重用改vptr。
5）若果派生类是从多个基类继承或者多个继承分支，则派生类将从这些分支的每个分支上继承一个vptr，编译器也会生成多个vtable。分别与它的多态基类对应。
6）vptr在派生类对象的相对位置不变，一般都放在所有数据成员的最前面。
7）为支持RTTI，为每个多态类创建一个type_info对象，并把其地址保存在vtable中的固定位置，一般为第一个。
3、虚函数指针的排序规律：
1）一个虚函数在当前class中第一次出现，则将其地址插入到该class的每一个vtable的尾部。
2）如果派生类改写了基类的虚函数，则函数的地址在派生类vtable的位置与在基类vtable中位置一致。
4、vptr处理过程：
1）vptr在根类的构造函数中被初始化，在后来的基类构造函数中，实际上都是在不断地被改写以指向当期构造函数对应的基类的vtable。
2）vptr必须随着对象类型的变化而不断地改变它的指向，以保证其值和当前对象的实际类型一致。
3）vptr肯定是第一个被初始化和改写的成员，在所有代码执行之前进行。
4）析构函数中，vptr则应该在所有用户代码指向完之后被改写为指向其直接基类的vtable。 因为在一个对象的析构过程中，是沿着继承分支向上依次退化为各个基类对象的。
5、虚函数
1）纯虚函数声明如下：virtual void funtion1()=0; 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。
2）虚函数声明如下：virtual ReturnType FunctionName(Parameter)；虚函数必须实现，如果不实现，编译器将报错。
3）对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。
4）实现了纯虚函数的子类，该纯虚函数在子类中就变成了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。
5）虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。
6）在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。
7）友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。
8）析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。
9）构造函数不能是虚函数。
6、多态性：每一个派生类的对象都可以被当做基类的对象使用，且派生的对象对同一个函数的调用做出不同的反应。实现机制为虚函数或者RTTI。
1）系统能够在运行时，能够根据其类型确定调用哪个重载的成员函数的能力，称为多态性，或叫滞后联编(late binding)。
2）多态特性的工作依赖虚函数的定义，在需要解决多态问题的重载成员函数前，加上virtual关键字，那么该成员函数就变成了虚函数。
7、隐含成员：有可能的隐含成员包括，若干vptr、默认构造函数、默认拷贝构造函数、析构函数和默认拷贝赋值函数。
8、static声明和定义的程序元素，无论作用域都是static存储类型，并且生存期限为永久，在程序开始时创建在结束时销毁。静态成员函数不需要this指针参数，通过作用域解析运算符(::)直接引用。
9、虚函数：一旦类的函数被声明为虚函数，其派生类的对应函数也自动成为虚函数。建议每一个派生层次显示的声明虚函数。
10、抽象基类：
1）不能被实例化的类，目的就是让其派生类继承并实现它的接口方法，通常也称为抽象基类。
2）函数初始化为0意味着函数的地址为0，编译器不会为该函数编址，从而阻止该类的实例化行为。
3）只有虚函数才能被初始化为0.
4）抽象类把数据和函数实现都隐藏在实现类中，在抽象类中提供丰富的接口函数。这样的抽象基类叫做接口类。
11、多态类：
1）每一个具有虚函数的类都叫做多态类，虚函数或者是从基类继承来的或是自己新增的。
2）编译器必须为每一个多态类至少创建一个虚函数表(vtable)，它其实是一个函数指针数组，存放着这个类的所有虚函数的地址和该类的类型信息，也包括那些继承但未改写(override)的虚函数。
3）每一个多态对象都有一个隐含的指针成员，指向所属类型的vtable，就是vptr。(*(p->_vptr[slotNum]))(p,arg-list);
12、派生类定义中的名字(对象或函数名)将义无反顾地屏蔽(即隐藏)掉基类的任何同名的对象或函数。
1）派生类定义一个与基类同名的虚函数，如果参数列表不同，编译器不会认为是对基类虚函数的改写，而是隐藏。不会发生运行时绑定。且派生类无法调用被隐藏的函数。
2）要达到运行时绑定的效果，派生类和基类中同名的虚函数必须具有相同的原型。
13、运行时多态实现方法：
1）经过隐含的转型操作，令一个public多态基类的指针或者引用指向一个派生类的对象。pShape = &aCircle;
2）通过这个指针或引用调用基类的虚函数，包括通过指针的反引用调用虚函数。pShape->Draw();或者(*pShape).Draw();
3）使用dynamic_cast<>和typeid运算符。

八、对象初始化、拷贝和析构
1、每个类只有一个析构函数、但可以有多个构造函数（包含一个拷贝构造函数，其他为普通构造函数）和多个赋值函数（包含一个拷贝赋值函数，其他为普通赋值函数）。如果不显示声明和定义，编译器将自动产生4个pubilc inline的默认函数。
A();//默认构造函数 
A(const A&);//默认拷贝构造函数
~A();//析构函数 
A& operator =(const A& a);//默认赋值函数
2、初始化：在对象创建的同时使用初值直接填充对象的内存单元，因此不会有数据类型的转换等中间过程。赋值：在对象创建好之后任何时候都可以调用的而且可以多次调用的函数，会产生临时对象。
3、最好为每个类显示定义构造函数和析构函数，即使暂时空着，尤其当类含有指针成员或者引用成员的时候。
4、初始化列表中：
1）初始化列表的初始化工作发生在初始化函数体内的任何代码被执行之前。
2）类的非静态const数据成员和引用对象只能在初始化列表里初始化。
3）类的数成员的初始化采用初始化列表或函数体内赋值均可，但对于成员对象(非基础数据类型)效率不同。初始化列表中对象直接通过拷贝构造函数对成员对象初始化；构造函数中先调用默认构造函数创建对象，再通过赋值函数将参数赋值给成员对象。
4）初始化列表真正的初始化顺序并不一定与初始化列表中安排一致，编译器按照在类中声明的次序来初始化。
5、构造函数：
1）构造函数分为：默认构造函数、拷贝构造函数和其他带参数的构造函数。默认构造函数只没有参数或者所有参数都有默认值的构造函数(两者不能同时存在)。
2）如果没有显式定义默认构造函数却定义了带参数的构造函数，那么后者的存在就会阻止编译器生成前者，于是类就没有默认构造函数。此时定义该类型的对象就会导致编译错误。
6、拷贝构造函数的参数必须是同类对象的引用，不能是对象值。因为拷贝构造函数在参数传递的过程中要调用拷贝构造函数本身，如果是值传递的，调用拷贝构造函数时要先进行参数传递，参数传递又要调用拷贝构造函数。陷入不停的分配堆栈的无限递归中。
7、如果不主动编写拷贝构造函数和拷贝赋值函数，编译器将以"按成员拷贝"的方式自动生成对应的默认函数。如果类中含有指针，则存在隐含的错误。
8、如果不想编写拷贝构造函数和拷贝赋值函数，可以讲拷贝构造函数和拷贝负责函数声明为private，并且不实现他们。甚至可以把类的所有构造函数和赋值函数都声明为private，这样可以彻底阻止该类的实例化。
9）基类的构造函数、析构函数、赋值构造函数不能在派生类被继承。
1）派生类的构造函数应在其初始化列表里显示的调用基类的构造函数。
2）如果基类是多态的，必须把基类的析构函数定义为虚函数，这样可以像其他虚函数一样实现动态绑定，否则可能造成内存泄露。
3）编写派生类的赋值函数时，不要忘记对基类的数据成员重新赋值，通过调用基类的赋值函数实现(基类成员可能是私有的)。








