一、基本概念
1、编译预处理、编译、连接。
2、内存映像：代码段、静态数据段、堆栈段。代码段包含源程序中的可执行语句序列；静态数据段存放全局变量、静态变量、符号表等；堆栈段留给函数和线程使用；
3、堆和自由存储空间不属于程序，属于操作系统，可以通过动态内存分配指令获取使用权。

二、程序入门
1、内部名称
1）C语言中，所有函数不是局部于编译单元的static函数，就是具有extern和global作用域的全局函数。不同编译单元中的static函数可以同名，全局函数不能同名。C语言转换时只说在函数名前面添加前缀'_'。
2）C++重命名在前面添加所属各级作用域及重载函数的经过编码的参数信息。
2、全局变量extern或者static存放在程序的静态数据区，在程序进入main()之前创建，在main()结束后销毁，编译器用0初始化。函数内的static局部变量和类中的static数据成员都具有static存储类型，会被移到程序的静态数据区，默认初始化为0。
3、区分初始化和赋值：前者发生在对象或变量创建的时候，后者在创建后进行。
4、字节是内存编址的最小单位，最小的对象(包括空对象)也至少占据1个字节的内存空间。
5、void类型指针和NULL指针区别：NULL是可以赋值给任何类型指针的值0，void*是合法指针，通常在函数参数中传递一个函数与期调用者之间约定好类型的对象地址；NULL是合法指针，但不是一个有效指针。
6、由于派生类和基类之间是is-a关系，可以直接将派生类对象转化为基类对象，虽然会发生内存截断，确是安全的。因为派生类对象必须保证其基类子对象完整性，基类子对象内存映像和真正的基类对象完全一样。
7、不可以把基类对象直接转换为派生类对象；对应基本类型的强制换行一定要区分值的截断和内存截断的不同。
8、两个同符号浮点数之差的绝对值小于或等于某个可接受的误差，就认为他们是相等的。
9、先列后行遍历发生的页面交换次数比先行后列多，且cache命中率相对也低。

三、常量
1、字面常量只能引用，不能修改。一般保存在程序的符号表里而不是一般的数据区。符号表是只读的。
2、#define定义的宏常量，在编译阶段前已经被替换为所代表的字面常量了，因此宏常量本质上是字面常量。
3、C++const定义的常量需根据具体情况定：对应基本数据类型，编译器会放到符号表中不分配存储空间。大对象需要分配存储空间。
4、对于基础数据类型的const常量，编译器会重新在内存创建一个拷贝；构造类型的const常量不会。
5、const和#define比较：
1）const常量有数据类型，宏常量没有数据类型。编译器可以对前者进行静态类型安全监测，后者只是字符替换，没有安全检查。
2）可以对const常量进行调试。
6、const可以用于：数据成员、成员函数、返回类型、const参数、符号常量。
7、类中的常量，非静态的const数据成员是属于每一个对象成员的，在某个对象生存期限内是常量，对整个类是可变的，除非是static const。非静态const数据成员只能在类构造函数的初始化列表中进行初始化。
8、C语言中const符号常量定义的默认连接类型是extern外连接，同全局变量。如果在头文件中定义必须使用static关键字，这样每一个包含该头文件的编译单元都会分别拥有该常量的独立定义实体。
9、C++中const默认连接类型是static，在头文件定义不需要static关键字。
10、const对指针的影响。const位于*左侧，用来修饰指针所指向的为常量。const位于*右侧，修饰指针本身，指针本身是常量。
1）const int *a; int const *a表示指针所指向的内容是常量，不能对内容进行更改操作；
2）int * const a表示指针本身是常量，不能对指针本身进行操作。

四、函数设计基础
1、函数堆栈作用：在进入函数前保持环境变量和返回地址；进入函数时保存实参的拷贝；在函数体内保存局部变量。
2、变量、常量和函数定义了4种存储类型：extern和static为永久的(在整个程序执行期间都存着)，auto和register为临时的(保存在堆栈和寄存器中)。
1）默认情况下，全局变量和全局函数的存储类型是extern。
2）变量和函数显式的加上extern声明，其他编译单元中的函数也能调用。为外连接。
3）变量和函数显式的加上static声明，只能被同一个编译单元的函数调用。为内连接。
4）全局常量默认存储类型是static。
3、使用const提高函数健壮性。
1）如果输入参数采用指针传递，加const修饰可以防止意外的改动该指针指向的内存单元，起到保护的作用；
2）如果给指针传递的函数返回值加上const，那么函数返回值是一种契约性常量，不能被直接修改，而且只能复制给加const修饰的同类型指针。eg：const char* GetString(void);const char *str = GetString()。

五、指针、数组
1、指针的值就是内存单元的地址。
2、函数指针传递其实是在传递一个地址二不是该地址指向的对象。双指针的传递(char **p)建议使用指针的引用(char* &p)。
3、数组名字本身就是一个指针，是一个指针常量，等价于int * const a; 数组名的值就是数组第一个元素的内存单元首地址，a = &a[0]。
4、二维数组等价于指向一维数组的指针，int b[3][4]等价于 int (* const b)[4]。三维数组等价于指向二维数组的指针，int (* const c)[4][5]。
5、把数组作为参数传递给函数时，并非把整个数组的内容传递进去，此时数组退化为一个同类型的指针。
6、对于多维数组传递，必须指出除第一维之外的所有维度的长度。void output(const int a[][20], int nums);
7、多维数组应转换为其等价的指向一维数组的指针。int a[m][n]等价int (*a)[n]。a是指向第一行的指针，a+1为指向第二行的指针。可转换为void output(const int (*a)[20],  int nums);
8、a[i][j]、(*(a+i))[j]、*(a[i]+j)、*(*(a+i)+j)四种表达等价。
9、删除数组空间时使用delete []p。
10、多维数组动态申请：char (*p)[4] = new char[3][4]; char (*q)[4][5] = new char[3][4][5]。



