一、基本概念
1、编译预处理、编译、连接。
2、内存映像：代码段、静态数据段、堆栈段。代码段包含源程序中的可执行语句序列；静态数据段存放全局变量、静态变量、符号表等；堆栈段留给函数和线程使用；
3、堆和自由存储空间不属于程序，属于操作系统，可以通过动态内存分配指令获取使用权。

二、程序入门
1、内部名称
1）C语言中，所有函数不是局部于编译单元的static函数，就是具有extern和global作用域的全局函数。不同编译单元中的static函数可以同名，全局函数不能同名。C语言转换时只说在函数名前面添加前缀'_'。
2）C++重命名在前面添加所属各级作用域及重载函数的经过编码的参数信息。
2、全局变量extern或者static存放在程序的静态数据区，在程序进入main()之前创建，在main()结束后销毁，编译器用0初始化。函数内的static局部变量和类中的static数据成员都具有static存储类型，会被移到程序的静态数据区，默认初始化为0。
3、区分初始化和赋值：前者发生在对象或变量创建的时候，后者在创建后进行。
4、字节是内存编址的最小单位，最小的对象(包括空对象)也至少占据1个字节的内存空间。
5、void类型指针和NULL指针区别：NULL是可以赋值给任何类型指针的值0，void*是合法指针，通常在函数参数中传递一个函数与期调用者之间约定好类型的对象地址；NULL是合法指针，但不是一个有效指针。
6、由于派生类和基类之间是is-a关系，可以直接将派生类对象转化为基类对象，虽然会发生内存截断，确是安全的。因为派生类对象必须保证其基类子对象完整性，基类子对象内存映像和真正的基类对象完全一样。
7、不可以把基类对象直接转换为派生类对象；对应基本类型的强制换行一定要区分值的截断和内存截断的不同。
8、两个同符号浮点数之差的绝对值小于或等于某个可接受的误差，就认为他们是相等的。
9、先列后行遍历发生的页面交换次数比先行后列多，且cache命中率相对也低。

三、常量
1、字面常量只能引用，不能修改。一般保存在程序的符号表里而不是一般的数据区。符号表是只读的。
2、#define定义的宏常量，在编译阶段前已经被替换为所代表的字面常量了，因此宏常量本质上是字面常量。
3、C++const定义的常量需根据具体情况定：对应基本数据类型，编译器会放到符号表中不分配存储空间。大对象需要分配存储空间。
4、对于基础数据类型的const常量，编译器会重新在内存创建一个拷贝；构造类型的const常量不会。
5、const和#define比较：
1）const常量有数据类型，宏常量没有数据类型。编译器可以对前者进行静态类型安全监测，后者只是字符替换，没有安全检查。
2）可以对const常量进行调试。
6、const可以用于：数据成员、成员函数、返回类型、const参数、符号常量。
7、类中的常量，非静态的const数据成员是属于每一个对象成员的，在某个对象生存期限内是常量，对整个类是可变的，除非是static const。非静态const数据成员只能在类构造函数的初始化列表中进行初始化。
8、C语言中const符号常量定义的默认连接类型是extern外连接，同全局变量。如果在头文件中定义必须使用static关键字，这样每一个包含该头文件的编译单元都会分别拥有该常量的独立定义实体。
9、C++中const默认连接类型是static，在头文件定义不需要static关键字。
10、const对指针的影响。const位于*左侧，用来修饰指针所指向的为常量。const位于*右侧，修饰指针本身，指针本身是常量。
1）const int *a; int const *a表示指针所指向的内容是常量，不能对内容进行更改操作；
2）int * const a表示指针本身是常量，不能对指针本身进行操作。

四、函数设计基础
1、函数堆栈作用：在进入函数前保持环境变量和返回地址；进入函数时保存实参的拷贝；在函数体内保存局部变量。
2、变量、常量和函数定义了4种存储类型：extern和static为永久的(在整个程序执行期间都存着)，auto和register为临时的(保存在堆栈和寄存器中)。
1）默认情况下，全局变量和全局函数的存储类型是extern。
2）变量和函数显式的加上extern声明，其他编译单元中的函数也能调用。为外连接。
3）变量和函数显式的加上static声明，只能被同一个编译单元的函数调用。为内连接。
4）全局常量默认存储类型是static。
3、使用const提高函数健壮性。
1）如果输入参数采用指针传递，加const修饰可以防止意外的改动该指针指向的内存单元，起到保护的作用；
2）如果给指针传递的函数返回值加上const，那么函数返回值是一种契约性常量，不能被直接修改，而且只能复制给加const修饰的同类型指针。eg：const char* GetString(void);const char *str = GetString()。

五、指针、数组
1、指针的值就是内存单元的地址。
2、函数指针传递其实是在传递一个地址二不是该地址指向的对象。双指针的传递(char **p)建议使用指针的引用(char* &p)。
3、数组名字本身就是一个指针，是一个指针常量，等价于int * const a; 数组名的值就是数组第一个元素的内存单元首地址，a = &a[0]。
4、二维数组等价于指向一维数组的指针，int b[3][4]等价于 int (* const b)[4]。三维数组等价于指向二维数组的指针，int (* const c)[4][5]。
5、把数组作为参数传递给函数时，并非把整个数组的内容传递进去，此时数组退化为一个同类型的指针。
6、对于多维数组传递，必须指出除第一维之外的所有维度的长度。void output(const int a[][20], int nums);
7、多维数组应转换为其等价的指向一维数组的指针。int a[m][n]等价int (*a)[n]。a是指向第一行的指针，a+1为指向第二行的指针。可转换为void output(const int (*a)[20],  int nums);
8、a[i][j]、(*(a+i))[j]、*(a[i]+j)、*(*(a+i)+j)四种表达等价。
9、删除数组空间时使用delete []p。
10、多维数组动态申请：char (*p)[4] = new char[3][4]; char (*q)[4][5] = new char[3][4][5]。
11、函数指针：int (*fun)(const char *);
1）函数指针是指向函数体的指针，其值是函数体的首地址。函数名就代表函数的首地址。
2）通过函数指针数组实现同类型函数的批量调用，在C++动态决议的虚拟机制中使用的vtable就是一个用来保存虚成员函数地址的函数指针数组。double (*fp[5])(double) = {sqrt, fabs, cos, sin, exp};
12、引用和指针的比较：
1）引用在创建的同时必须初始化，即引用一个有效的对象；指针不必初始化，可以在定义后任何地方赋值。
2）不存在NULL的引用，引用必须和合法的存储单元关联；指针可以是NULL。
3）引用一旦被初始化就不能被改变，指针可以改变为指向另一个对象。
4）引用的创建和销毁并不会调用类的拷贝构造函数和析构函数。
5）语言层面上，引用的用法和对象一样；二进制层面，引用一杯通过指针来实现的，不过编译器帮我们完成转换。

六、高级数据类型
1、struct和class除了"默认的成员访问权限"不用外，其他没有区别。struct默认访问限定符为public，class默认是private。
2、成员对齐：
1）对应复合类型(结构或类)的对象，如果他的起始地址能够满足其中要求最严格的那个数据成员的自然对齐要求，那么他就是自然对齐的。
2）如果那个数据成员又是一个复合类型的对象，则依次类推，知道最后都是基本类型的数据成员。
3）一般都采用按照声明的先后顺序从低地址到高地址依次布放。
4）编译器在考虑一个类型的大小时，不仅要考虑一个对象的对齐要求，还要考虑该类型对象数组的对齐要求，保证使用对象数组和单个对象访问效率一样。
struct R{
char m_ch;
double m_width;
char m_name[6];
}; //24字节
struct T{
int m_no;
R m_r;
}; //32字节
struct U{
bool m_ok;
T m_t;
}; //40字节
5）为节省内存可以按照从大到小的顺序从前到后依次声明数据成员。
3、枚举enum允许我们定义特定用途的一组符号常量，表明这种类型的变量可以取值的范围。使用匿名枚举来定义程序相关常量集合，可以取代宏常量和const常量。
enum{
    AAA = 1;
    BBB = 2;
};
4、头文件的所有内容最终都会被合并到一个或几个源文件中，每一个包含的头文件递归的展开后形成的源文件叫编译单元。

七、面向对象程序设计
1、C++对象模型：
1）非静态数据成员放在每一个对象体内作为对象专有的数据成员。
2）静态数据成员被提取出来放在程序的静态数据区内，该类所有对象共享，仅存在一份。
3）静态和非静态成员函数都被提取放在程序的代码段中并为该类的所有对象共享，每个成员函数只有一份代码实体。
4）类内嵌套定义的各种类型与放在类外面除了作用域不同外没有本质区别。
5）构成对象本身的只有数据，任何成员函数都不隶属于任何一个对象，非静态成员函数与对象的关系就是绑定，绑定的中介就是this指针。
2、增加了继承和虚函数的类
1）派生类继承基类的非静态数据成员，并作为自己对象的专用数据成员。
2）派生类继承基类的非静态成员函数，并作为自己的成员函数一样访问。
3）为每一个多态类创建一个虚函数指针数组vtable(在静态数据区)，该类的所有虚函数(继承自基类或者新增的)的地址都保存在这张表。
4）如果基类已经插入了vptr，派生类将继承和重用改vptr。
5）若果派生类是从多个基类继承或者多个继承分支，则派生类将从这些分支的每个分支上继承一个vptr，编译器也会生成多个vtable。分别与它的多态基类对应。
6）vptr在派生类对象的相对位置不变，一般都放在所有数据成员的最前面。
7）为支持RTTI，为每个多态类创建一个type_info对象，并把其地址保存在vtable中的固定位置，一般为第一个。
3、虚函数指针的排序规律：
1）一个虚函数在当前class中第一次出现，则将其地址插入到该class的每一个vtable的尾部。
2）如果派生类改写了基类的虚函数，则函数的地址在派生类vtable的位置与在基类vtable中位置一致。
4、vptr处理过程：
1）vptr在根类的构造函数中被初始化，在后来的基类构造函数中，实际上都是在不断地被改写以指向当期构造函数对应的基类的vtable。
2）vptr必须随着对象类型的变化而不断地改变它的指向，以保证其值和当前对象的实际类型一致。
3）vptr肯定是第一个被初始化和改写的成员，在所有代码执行之前进行。
4）析构函数中，vptr则应该在所有用户代码指向完之后被改写为指向其直接基类的vtable。 因为在一个对象的析构过程中，是沿着继承分支向上依次退化为各个基类对象的。
5、虚函数
1）纯虚函数声明如下：virtual void funtion1()=0; 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。
2）虚函数声明如下：virtual ReturnType FunctionName(Parameter)；虚函数必须实现，如果不实现，编译器将报错。
3）对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。
4）实现了纯虚函数的子类，该纯虚函数在子类中就变成了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。
5）虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。
6）在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。
7）友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。
8）析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。
9）构造函数不能是虚函数。
6、多态性：每一个派生类的对象都可以被当做基类的对象使用，且派生的对象对同一个函数的调用做出不同的反应。实现机制为虚函数或者RTTI。
1）系统能够在运行时，能够根据其类型确定调用哪个重载的成员函数的能力，称为多态性，或叫滞后联编(late binding)。
2）多态特性的工作依赖虚函数的定义，在需要解决多态问题的重载成员函数前，加上virtual关键字，那么该成员函数就变成了虚函数。
7、隐含成员：有可能的隐含成员包括，若干vptr、默认构造函数、默认拷贝构造函数、析构函数和默认拷贝赋值函数。
8、static声明和定义的程序元素，无论作用域都是static存储类型，并且生存期限为永久，在程序开始时创建在结束时销毁。静态成员函数不需要this指针参数，通过作用域解析运算符(::)直接引用。
9、虚函数：一旦类的函数被声明为虚函数，其派生类的对应函数也自动成为虚函数。建议每一个派生层次显示的声明虚函数。
10、抽象基类：
1）不能被实例化的类，目的就是让其派生类继承并实现它的接口方法，通常也称为抽象基类。
2）函数初始化为0意味着函数的地址为0，编译器不会为该函数编址，从而阻止该类的实例化行为。
3）只有虚函数才能被初始化为0.
4）抽象类把数据和函数实现都隐藏在实现类中，在抽象类中提供丰富的接口函数。这样的抽象基类叫做接口类。
11、多态类：
1）每一个具有虚函数的类都叫做多态类，虚函数或者是从基类继承来的或是自己新增的。
2）编译器必须为每一个多态类至少创建一个虚函数表(vtable)，它其实是一个函数指针数组，存放着这个类的所有虚函数的地址和该类的类型信息，也包括那些继承但未改写(override)的虚函数。
3）每一个多态对象都有一个隐含的指针成员，指向所属类型的vtable，就是vptr。(*(p->_vptr[slotNum]))(p,arg-list);
12、派生类定义中的名字(对象或函数名)将义无反顾地屏蔽(即隐藏)掉基类的任何同名的对象或函数。
1）派生类定义一个与基类同名的虚函数，如果参数列表不同，编译器不会认为是对基类虚函数的改写，而是隐藏。不会发生运行时绑定。且派生类无法调用被隐藏的函数。
2）要达到运行时绑定的效果，派生类和基类中同名的虚函数必须具有相同的原型。
13、运行时多态实现方法：
1）经过隐含的转型操作，令一个public多态基类的指针或者引用指向一个派生类的对象。pShape = &aCircle;
2）通过这个指针或引用调用基类的虚函数，包括通过指针的反引用调用虚函数。pShape->Draw();或者(*pShape).Draw();
3）使用dynamic_cast<>和typeid运算符。

八、对象初始化、拷贝和析构
1、每个类只有一个析构函数、但可以有多个构造函数（包含一个拷贝构造函数，其他为普通构造函数）和多个赋值函数（包含一个拷贝赋值函数，其他为普通赋值函数）。如果不显示声明和定义，编译器将自动产生4个pubilc inline的默认函数。
A();//默认构造函数 
A(const A&);//默认拷贝构造函数
~A();//析构函数 
A& operator =(const A& a);//默认赋值函数
2、初始化：在对象创建的同时使用初值直接填充对象的内存单元，因此不会有数据类型的转换等中间过程。赋值：在对象创建好之后任何时候都可以调用的而且可以多次调用的函数，会产生临时对象。
3、最好为每个类显示定义构造函数和析构函数，即使暂时空着，尤其当类含有指针成员或者引用成员的时候。
4、初始化列表中：
1）初始化列表的初始化工作发生在初始化函数体内的任何代码被执行之前。
2）类的非静态const数据成员和引用对象只能在初始化列表里初始化。
3）类的数成员的初始化采用初始化列表或函数体内赋值均可，但对于成员对象(非基础数据类型)效率不同。初始化列表中对象直接通过拷贝构造函数对成员对象初始化；构造函数中先调用默认构造函数创建对象，再通过赋值函数将参数赋值给成员对象。
4）初始化列表真正的初始化顺序并不一定与初始化列表中安排一致，编译器按照在类中声明的次序来初始化。
5、构造函数：
1）构造函数分为：默认构造函数、拷贝构造函数和其他带参数的构造函数。默认构造函数只没有参数或者所有参数都有默认值的构造函数(两者不能同时存在)。
2）如果没有显式定义默认构造函数却定义了带参数的构造函数，那么后者的存在就会阻止编译器生成前者，于是类就没有默认构造函数。此时定义该类型的对象就会导致编译错误。
6、拷贝构造函数的参数必须是同类对象的引用，不能是对象值。因为拷贝构造函数在参数传递的过程中要调用拷贝构造函数本身，如果是值传递的，调用拷贝构造函数时要先进行参数传递，参数传递又要调用拷贝构造函数。陷入不停的分配堆栈的无限递归中。
7、如果不主动编写拷贝构造函数和拷贝赋值函数，编译器将以"按成员拷贝"的方式自动生成对应的默认函数。如果类中含有指针，则存在隐含的错误。
8、如果不想编写拷贝构造函数和拷贝赋值函数，可以讲拷贝构造函数和拷贝负责函数声明为private，并且不实现他们。甚至可以把类的所有构造函数和赋值函数都声明为private，这样可以彻底阻止该类的实例化。
9）基类的构造函数、析构函数、赋值构造函数不能在派生类被继承。
1）派生类的构造函数应在其初始化列表里显示的调用基类的构造函数。
2）如果基类是多态的，必须把基类的析构函数定义为虚函数，这样可以像其他虚函数一样实现动态绑定，否则可能造成内存泄露。
3）编写派生类的赋值函数时，不要忘记对基类的数据成员重新赋值，通过调用基类的赋值函数实现(基类成员可能是私有的)。

九、函数高级特征
1、全局函数和类函数同名不算重载，因为作用域不同。调用全局函数时为调用全局函数，前面加作用域结息运算符(::)。
2、成员函数重载：
1）具有相同作用域(即在同一个类定义)。
2）函数名字相同。
3）参数类型、顺序或数目不同(包含const参数和非const参数)。
4）virtual关键字可有可无。
3、覆盖是值派生类重新实现(override)了基类的成员函数:
1）不同的作用域(分别位于派生类和基类中)。
2）函数名相同。
3）参数列表完全相同。
4）基类函数必须是虚函数。
4、隐藏：
1）派生类的函数和基类的函数同名，但是参数列表有所差异。此时无论有无virtual关键字，基类的函数在派生类中将被隐藏。
2）派生类的函数与基类的函数同名，参数列表也相同，但基类函数没有virtual关键字。此时基类的函数在派生类中将被隐藏(注意别和覆盖混淆)。
5、重置++和--
1）Integer& operator ++(){
    //前置版本
    m_data++;
    return *this;
};
2）Integer& operator ++(int) {
    //后置版本
    Integer tmp = *this;
    m_data++;
    return tmp;  
};
3)后置版本总是要创建一个临时对象，在退出函数时销毁他，并且返回临时变量对象的值的时候调用拷贝构造函数。效率较前置低。
6、内联函数
1）编译器在符号表里放入内联函数的声明，如果编译器没有发现内联函数错误，那么该函数的代码也放在符号表里。
2）编译器会把内联函数的代码直接替换函数调用语句，于是省去了函数调用的开销。
3）内联机制即具备宏代码的效率，又增加了安全性。
4）inline关键字必须和函数定义体放在一起才能是函数真正内联。
5）内联是以代码膨胀为代价，仅仅省去了函数调用的开销，从而提高程序执行效率。但是会提高代码量，消耗更多内存空间。
7、类型转换运算符：
1）static_cast<dest_type>(src_obj)相当于C的强制转换。使用它做downcast操作，会存在隐患。
2）const_cast<dest_type>(src_obj)去除一个对象的const/volatile属性。
3）reinterpret_cast<dest_type>(src_obj)任何两种类型的指针之间转换。不要轻易使用。
4）dynamic_cast<dest_type>(src_obj)在运行时遍历继承树(类层次结构)，来确定src_obj与dest_type的关系。
8、const成员函数
1）任何不会修改数据成员的成员函数都应该声明成const类型。const关键字在放在函数声明的尾部。
2）不要混淆const成员函数和成员函数返回const类型。两者没有必然联系。
9、RTTI(Run-time Type Identification)
1）RTTI和虚函数不是一回事儿，实际上虚函数的动态绑定并没有使用对象的type_info信息。
2）有了RTTI就能在运行时查询一个多态指针或者引用指向的具体对象的类型了。
3）运算符有typeid和dynamic_cast<>。
10、typeid返回一个匹配的const type_info对象，表名改对象的确切类型。typeid(device) == typeid(Television); Television *p = static_cast<Television *>(&device);
11、dynamic_cast<>：
1）typeid()返回的是一个对象确切的类型而不是基类型。不具备扩展性。
2）dynamic_cast<>可以用来转换指针和引用，单不能转换对象。当目标类型是某类型的指针时，成功返回目标类型指针，否则返回NULL。Television *p = dynamic_cast<Television *>(&device);
3）当目标类型为某类型的引用时，成功返回目标类型的引用，否则抛出std::bad_cast异常，因为不存在NULL的引用。Television &tv = dynamic_cast<Television &>(device);
4）dynamic_cast<>只能用于多态类型对象(拥有虚函数或虚拟继承)，否则将导致编译时错误。
5）upcast方向：把派生类型的指针、引用转换为基类型的指针或引用。downcast方向：基类型的指针或引用转换为派生类的指针或引用。如果这个基类型的指针或者引用确实指向一个这种派生类的对象，那么转换就会成功，否则失败。
6）为了支持dynamic_cast<>对象，RTTI机制必须维护一颗继承树用于判断源对象和目标类型之间是否具有is-a关系。typeid()和虚函数动态绑定不需要继承树。可以看出，虚函数的动态绑定记账是"精确的"对象类型匹配，dynamic_cast<>是"模糊的"对象类型批量。
7）dynamic_cast<>转换引用是，保证程序有一条catch()处理std::bad_cast异常；转换指针时，要记住检查返回值是否为NULL。
8）无论基本类型还是用户定义类型，都需要额外的内存存放type_info对象。对于多态类：增加一个指针成员、一个type_info对象以及给虚函数表增加一项。 

十、内存管理
1、内存分配方式：
1）静态存储区域分配。内存在函数编译的时候就已经分配好了，这些内存在程序整个运行期间都存在，如全局变量、static变量。
2）堆栈分配。函数执行期间，函数内局部变量(包含形参)的存储单元都创建在堆栈上，函数结束时这些存储单元自动释放(堆栈清退)。但分配的内存容量有限，可能出现堆栈溢出。
3）堆(heap)或自由空间分配，亦称动态内存分配。运行期间用mallco()或new申请任意数量的内存，程序员自己掌握释放内存的恰当时机(使用free()或delete)。
4）一般原则：如果使用堆栈存储和静态存储就能满足应用要求，就不要使用动态存储。
2、常见内存错误和对策：
1）malloc或new后应该立刻检查指针值是否为NULL，防止使用NULL指针。
2）不要忘记初始化指针。
3）避免数组或职责下标越界。
4）动态内存申请与释放必须配对，避免内存泄漏。
5）free或delete释放内存后，立即将指针置为NULL，防止产生"野指针"。
3、函数参数是一个指针，不要指望用该指针去申请动态内存。形参申请内存后，形参指向新的内存地址，而传入参数本身并未改变。如果非要用指针参数去申请内存，应该该用"指向指针的指针"或者"指针的引用"。
4、可以用函数返回值来传递动态内存，但是不用用return语句返回指向"栈内存"的指针或引用，因为该内存在函数结束时将自动释放。
5、char p[] = "hello wordl"; char *p = "hello world";第二句"hello world"是常量字符串，位于静态存储区，在程序生命期内始终有效。
6、free和delete把指针所指的内存给释放掉，并没有把指针本身删除。释放后应将指针置为NULL，避免误用。
7、指针消亡了，并不表示它所指向的内存会被自动释放；内存被释放了，并不表示指针会消亡或者成为NULL。
8、野指针不是NULL指针，而是指向"非法"内存的指针。
9、new/delete相对malloc/free在对象创建的同时会调用构造函数，销毁时调用析构函数。malloc/free申请后需要另外初始化。
10.malloc/free使用要点：int *p = (int*)malloc(sizeof(int))
1）malloc函数返回值类型是void，调用后要显式的进行类型转换，将void*转换成需要的指针类型。
2）malloc函数本身不识别要申请内存是什么类型，只关心内存的总字节数。
11、new的3种使用方式：
1）plain new/delete，平时使用的普通的new，没有附加成分。分配失败会抛出标准异常std::bad_alloc而不是返回null。char *p = new char[size];
2）nothrow new/delete, 不抛出异常的运算符new的形式，nothrow new在失败时返回NULL。char *p = new(nothrow) char[size];
3）placement new/delete，在一块已经分配成功的内存上重新构造对象或者对象数组。不用担心内存分配失败，因为根本没有分配内存，只是调用对象的构造函数。char *p = new char[100]; int *q = new(p) int[100/sizeof(int)];
12、new/delete和new[]/delete[]必须正确配对使用。多次delete一个不等于NULL的指针会导致运行时报错，多次delete一个NULL指针没有任何危险。
