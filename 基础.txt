一、基本概念
1、编译预处理、编译、连接。
2、内存映像：代码段、静态数据段、堆栈段。代码段包含源程序中的可执行语句序列；静态数据段存放全局变量、静态变量、符号表等；堆栈段留给函数和线程使用；
3、堆和自由存储空间不属于程序，属于操作系统，可以通过动态内存分配指令获取使用权。

二、程序入门
1、内部名称
1）C语言中，所有函数不是局部于编译单元的static函数，就是具有extern和global作用域的全局函数。不同编译单元中的static函数可以同名，全局函数不能同名。C语言转换时只说在函数名前面添加前缀'_'。
2）C++重命名在前面添加所属各级作用域及重载函数的经过编码的参数信息。
2、全局变量extern或者static存放在程序的静态数据区，在程序进入main()之前创建，在main()结束后销毁，编译器用0初始化。函数内的static局部变量和类中的static数据成员都具有static存储类型，会被移到程序的静态数据区，默认初始化为0。
3、区分初始化和赋值：前者发生在对象或变量创建的时候，后者在创建后进行。
4、字节是内存编址的最小单位，最小的对象(包括空对象)也至少占据1个字节的内存空间。
5、void类型指针和NULL指针区别：NULL是可以赋值给任何类型指针的值0，void*是合法指针，通常在函数参数中传递一个函数与期调用者之间约定好类型的对象地址；NULL是合法指针，但不是一个有效指针。
6、由于派生类和基类之间是is-a关系，可以直接将派生类对象转化为基类对象，虽然会发生内存截断，确是安全的。因为派生类对象必须保证其基类子对象完整性，基类子对象内存映像和真正的基类对象完全一样。
7、不可以把基类对象直接转换为派生类对象；对应基本类型的强制换行一定要区分值的截断和内存截断的不同。
8、两个同符号浮点数之差的绝对值小于或等于某个可接受的误差，就认为他们是相等的。
9、先列后行遍历发生的页面交换次数比先行后列多，且cache命中率相对也低。

三、常量
1、字面常量只能引用，不能修改。一般保存在程序的符号表里而不是一般的数据区。符号表是只读的。
2、#define定义的宏常量，在编译阶段前已经被替换为所代表的字面常量了，因此宏常量本质上是字面常量。
3、C++const定义的常量需根据具体情况定：对应基本数据类型，编译器会放到符号表中不分配存储空间。大对象需要分配存储空间。
4、对于基础数据类型的const常量，编译器会重新在内存创建一个拷贝；构造类型的const常量不会。
5、const和#define比较：
1）const常量有数据类型，宏常量没有数据类型。编译器可以对前者进行静态类型安全监测，后者只是字符替换，没有安全检查。
2）可以对const常量进行调试。
6、const可以用于：数据成员、成员函数、返回类型、const参数、符号常量。
